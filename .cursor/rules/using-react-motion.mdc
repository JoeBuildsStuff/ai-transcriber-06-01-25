---
description: Use this when user asks to use motion or when editing a file that uses motion
alwaysApply: false
---
React animation
New to Motion? Start with the Motion for React quickstart guide

Motion for React is a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.

What you'll learn
How to create your first animation with the <motion.div /> component.

Which values and elements you can animate.

How to customise your animations with transition options.

How to animate elements as they enter and exit the DOM.

How to orchestrate animations with variants.

Note: If you haven't installed Motion already, hop over to the quick start guide for full instructions.

Animate with <motion />
Most animations in Motion are created with the <motion /> component. Import it from "motion/react":

import { motion } from "motion/react"
Every HTML & SVG element can be defined with a motion component:

<motion.div />
<motion.a href="#" />
<motion.circle cx={0} />
These components are exactly the same as their normal static counterparts, except now they have access to a bunch of special animation props.

The most common animation prop is animate. When values passed to animate change, the element will automatically animate to that value.

<motion.div animate={{ opacity: 1 }} />

Enter animations
We can set initial values for an element with the initial prop. So an element defined like this will fade in when it enters the DOM:

<motion.article
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
/>
Animatable values
Motion can animate any CSS value, like opacity, filter etc.

<motion.section
  initial={{ filter: "blur(10px)" }}
  animate={{ filter: "none" }}
/>
It can even animate values that aren't normally animatable by browsers, like background-image or mask-image:

<motion.nav
  initial={{ maskImage: "linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)" }}
  animate={{ maskImage: "linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)" }}
/>
Transforms
Unlike CSS, Motion can animate every transform axis independently.

<motion.div animate={{ x: 100 }} />
It supports the following special transform values:

Translate: x, y, z

Scale: scale, scaleX, scaleY

Rotate: rotate, rotateX, rotateY, rotateZ

Skew: skew, skewX, skewY

Perspective: transformPerspective

motion components also have enhanced style props, allowing you to use these shorthands statically:

<motion.section style={{ x: -20 }} />
Animating transforms independently provides great flexibility, especially when animating different transforms with gestures:

<motion.button
  initial={{ y: 10 }}
  animate={{ y: 0 }}
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.9 }}
/>
Performance tip: Independent transforms already perform great, but Motion uniquely offers hardware acceleration when setting transform directly:

<motion.li
  initial={{ transform: "translateX(-100px)" }}
  animate={{ transform: "translateX(0px)" }}
  transition={{ type: "spring" }}
/>
SVG note: For SVG components, x and y attributes can be set using attrX and attrY. Learn more about SVG animations in React.

Supported value types
Motion can animate any of the following value types:

Numbers: 0, 100 etc.

Strings containing numbers: "0vh", "10px" etc.

Colors: Hex, RGBA, HSLA.

Complex strings containing multiple numbers and/or colors (like box-shadow).

display: "none"/"block" and visibility: "hidden"/"visible".

Value type conversion
In general, values can only be animated between two of the same type (i.e "0px" to "100px").

Colors can be freely animated between hex, RGBA and HSLA types.

Additionally, x, y, width, height, top, left, right and bottom can animate between different value types.

<motion.div
  initial={{ x: "100%" }}
  animate={{ x: "calc(100vw - 50%)" }}
/>
It's also possible to animate width and height in to/out of "auto".

<motion.div
  initial={{ height: 0 }}
  animate={{ height: "auto" }}
/>
Note: If additionally animating display in to/out of "none", replace this with visibility "hidden" as elements with display: none can't be measured.

Transform origin
transform-origin has three shortcut values that can be set and animated individually:

originX

originY

originZ

If set as numbers, originX and Y default to a progress value between 0 and 1. originZ defaults to pixels.

<motion.div style={{ originX: 0.5 }} />
CSS variables
Motion for React can animate CSS variables, and also use CSS variable definitions as animation targets.

Animating CSS variables
Sometimes it's convenient to be able to animate a CSS variable to animate many children:

<motion.ul
  initial={{ '--rotate': '0deg' }}
  animate={{ '--rotate': '360deg' }}
  transition={{ duration: 2, repeat: Infinity }}
>
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
</motion.ul>
Note: Animating the value of a CSS variable always triggers paint, therefore it can be more performant to use MotionValues to setup this kind of animation.

CSS variables as animation targets
HTML motion components accept animation targets with CSS variables:

<motion.li animate={{ backgroundColor: "var(--action-bg)" }} />
Transitions
By default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.

For instance, physical properties like x or scale are animated with spring physics, whereas values like opacity or color are animated with duration-based easing curves.

However, you can define your own animations via the transition prop.

<motion.div
  animate={{ x: 100 }}
  transition={{ ease: "easeOut", duration: 2 }}
/>
A default transition can be set for many components with the MotionConfig component:

<MotionConfig transition={{ duration: 0.3 }}>
  <motion.div animate={{ opacity: 1 }} />
  // etc
Or you can set a specific transition on any animation prop:

<motion.div
  animate={{ opacity: 1 }}
  whileHover={{
    opacity: 0.7,
    // Specific transitions override default transitions
    transition: { duration: 0.3 }
  }}
  transition={{ duration: 0.5 }}
/>
Enter animations
When a motion component is first created, it'll automatically animate to the values in animate if they're different from those initially rendered, which you can either do via CSS or via the initial prop. 

<motion.li
  initial={{ opacity: 0, scale: 0 }}
  animate={{ opacity: 1, scale: 1 }}
/>

You can also disable the enter animation entirely by setting initial={false}. This will make the element render with the values defined in animate.

<motion.div initial={false} animate={{ y: 100 }} />
Exit animations
Motion for React can animate elements as they're removed from the DOM.

In React, when a component is removed, it's usually removed instantly. Motion provides the AnimatePresence component which keeps elements in the DOM while they perform an animation defined with the exit prop.

<AnimatePresence>
  {isVisible && (
    <motion.div
      key="modal"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    />
  )}
</AnimatePresence>

Keyframes
So far, we've set animation props like animate and exit to single values, like opacity: 0.

This is great when we want to animate from the current value to a new value. But sometimes we want to animate through a series of values. In animation terms, these are called keyframes.

All animation props can accept keyframe arrays:

<motion.div animate={{ x: [0, 100, 0] }} />

When we animate to an array of values, the element will animate through each of these values in sequence.

In the previous example, we explicitly set the initial value as 0. But we can also say "use the current value" by setting the first value to null.

<motion.div animate={{ x: [null, 100, 0] }} />

This way, if a keyframe animation is interrupting another animation, the transition will feel more natural.

Wildcard keyframes
This null keyframe is called a wildcard keyframe. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).

Wildcard keyframes can be useful for holding a value mid-animation without having to repeat values.

<motion.div
  animate={{ x: [0, 100, null, 0 ] }}
  // same as x: [0, 100, 100, 0] but easier to maintain
/>
Keyframe timing
By default, each keyframe is spaced evenly throughout the animation. You can override this by setting the times option via transition.

times is an array of progress values between 0 and 1, defining where in the animation each keyframe should be positioned.

<motion.circle
  cx={500}
  animate={{
    cx: [null, 100, 200],
    transition: { duration: 3, times: [0, 0.2, 1] }
  }}
/>
0 is the start of the animation, and 1 is the end of the animation. Therefore, 0.2 places this keyframe somewhere towards the start of the animation.

Gesture animations
Motion for React has animation props that can define how an element animates when it recognises a gesture.

Supported gestures are:

whileHover

whileTap

whileFocus

whileDrag

whileInView

When a gesture starts, it animates to the values defined in while-, and then when the gesture ends it animates back to the values in initial or animate.

<motion.button
  initial={{ opacity: 0 }}
  whileHover={{ backgroundColor: "rgba(220, 220, 220, 1)" }}
  whileTap={{ backgroundColor: "rgba(255, 255, 255, 1)" }}
  whileInView={{ opacity: 1 }}
/>

The custom Cursor component available in Motion+ takes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):

<Cursor magnetic />

Variants
Setting animate as a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.

Variants are a set of named targets. These names can be anything.

const variants = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}
Variants are passed to motion components via the variants prop:

<motion.div variants={variants} />
These variants can now be referred to by a label, wherever you can define an animation target:

<motion.div
  variants={variants}
  initial="hidden"
  whileInView="visible"
  exit="hidden"
/>
You can also define multiple variants via an array:

animate={["visible", "danger"]}
I love using variants alongside React state – just pass your state to animate, and now you've got a tidy place to define all your animation targets!

const [status, setStatus] = useState<"inactive" | "active" | "complete">(
  "inactive"
);

<motion.div
  animate={status} // pass in our React state!
  variants={{
    inactive: { scale: 0.9 color: "var(--gray-500)" },
    active: { scale: 1 color: "var(--blue-500)" },
    complete: { scale: 1 color: "var(--blue-500)" }
  }}
>
  <motion.svg
    path={checkmarkPath}
    variants={{
      inactive: { pathLength: 0 },
      active: { pathLength: 0 },
      complete: { pathLength: 1}
    }}
  />
</motion.div>
~ Sam Selikoff


Propagation
Variants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.

Variants will flow down through motion components. So in this example when the ul enters the viewport, all of its children with a "visible" variant will also animate in:

const list = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

const item = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
}

return (
  <motion.ul
    initial="hidden"
    whileInView="visible"
    variants={list}
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)

Orchestration
By default, this children animations will start simultaneously with the parent. But with variants we gain access to new transition props when and delayChildren.

const list = {
  visible: {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      delayChildren: stagger(0.3), // Stagger children by .3 seconds
    },
  },
  hidden: {
    opacity: 0,
    transition: {
      when: "afterChildren",
    },
  },
}
Dynamic variants
Each variant can be defined as a function that resolves when a variant is made active.

const variants = {
  hidden: { opacity: 0 },
  visible: (index) => ({
    opacity: 1,
    transition: { delay: index * 0.3 }
  })
}
These functions are provided a single argument, which is passed via the custom prop:

items.map((item, index) => <motion.div custom={index} variants={variants} />)
This way, variants can be resolved differently for each animating element.

Animation controls
Declarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.

The useAnimate hook can be used for:

Animating any HTML/SVG element (not just motion components).

Complex animation sequences.

Controlling animations with time, speed, play(), pause() and other playback controls.

function MyComponent() {
  const [scope, animate] = useAnimate()

  useEffect(() => {
    const controls = animate([
      [scope.current, { x: "100%" }],
      ["li", { opacity: 1 }]
    ])

    controls.speed = 0.8

    return () => controls.stop()
  }, [])

  return (
    <ul ref={scope}>
      <li />
      <li />
      <li />
    </ul>
  )
}
Animate content
By passing a MotionValue as the child of a motion component, it will render its latest value in the HTML.

import { useMotionValue, motion, animate } from "motion/react"

function Counter() {
  const count = useMotionValue(0)

  useEffect(() => {
    const controls = animate(count, 100, { duration: 5 })
    return () => controls.stop()
  }, [])

  return <motion.pre>{count}</motion.pre>
}
This is more performant than setting React state as the motion component will set innerHTML directly.


It's also possible to animate numbers with a ticking counter effect using the AnimateNumber component in Motion+ by passing them directly to the component:

<AnimateNumber>{value}</AnimateNumber>

Next
In this guide we've covered the basic kinds of animations we can perform in Motion using its animation props. However, there's much more to discover.

Most of the examples on this page have used HTML elements, but Motion also has unique SVG animation features, like its simple line drawing API.

We've also only covered time-based animations, but Motion also provides powerful scroll animation features like useScroll and whileInView.

It also provides a powerful layout animation engine, that can animate between any two layouts using performant transforms.

Finally, there's also a whole Fundamentals examples category that covers all the basics of animating with Motion for React with live demos and copy-paste code.React animation
New to Motion? Start with the Motion for React quickstart guide

Motion for React is a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.

What you'll learn
How to create your first animation with the <motion.div /> component.

Which values and elements you can animate.

How to customise your animations with transition options.

How to animate elements as they enter and exit the DOM.

How to orchestrate animations with variants.

Note: If you haven't installed Motion already, hop over to the quick start guide for full instructions.

Animate with <motion />
Most animations in Motion are created with the <motion /> component. Import it from "motion/react":

import { motion } from "motion/react"
Every HTML & SVG element can be defined with a motion component:

<motion.div />
<motion.a href="#" />
<motion.circle cx={0} />
These components are exactly the same as their normal static counterparts, except now they have access to a bunch of special animation props.

The most common animation prop is animate. When values passed to animate change, the element will automatically animate to that value.

<motion.div animate={{ opacity: 1 }} />

Enter animations
We can set initial values for an element with the initial prop. So an element defined like this will fade in when it enters the DOM:

<motion.article
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
/>
Animatable values
Motion can animate any CSS value, like opacity, filter etc.

<motion.section
  initial={{ filter: "blur(10px)" }}
  animate={{ filter: "none" }}
/>
It can even animate values that aren't normally animatable by browsers, like background-image or mask-image:

<motion.nav
  initial={{ maskImage: "linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)" }}
  animate={{ maskImage: "linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)" }}
/>
Transforms
Unlike CSS, Motion can animate every transform axis independently.

<motion.div animate={{ x: 100 }} />
It supports the following special transform values:

Translate: x, y, z

Scale: scale, scaleX, scaleY

Rotate: rotate, rotateX, rotateY, rotateZ

Skew: skew, skewX, skewY

Perspective: transformPerspective

motion components also have enhanced style props, allowing you to use these shorthands statically:

<motion.section style={{ x: -20 }} />
Animating transforms independently provides great flexibility, especially when animating different transforms with gestures:

<motion.button
  initial={{ y: 10 }}
  animate={{ y: 0 }}
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.9 }}
/>
Performance tip: Independent transforms already perform great, but Motion uniquely offers hardware acceleration when setting transform directly:

<motion.li
  initial={{ transform: "translateX(-100px)" }}
  animate={{ transform: "translateX(0px)" }}
  transition={{ type: "spring" }}
/>
SVG note: For SVG components, x and y attributes can be set using attrX and attrY. Learn more about SVG animations in React.

Supported value types
Motion can animate any of the following value types:

Numbers: 0, 100 etc.

Strings containing numbers: "0vh", "10px" etc.

Colors: Hex, RGBA, HSLA.

Complex strings containing multiple numbers and/or colors (like box-shadow).

display: "none"/"block" and visibility: "hidden"/"visible".

Value type conversion
In general, values can only be animated between two of the same type (i.e "0px" to "100px").

Colors can be freely animated between hex, RGBA and HSLA types.

Additionally, x, y, width, height, top, left, right and bottom can animate between different value types.

<motion.div
  initial={{ x: "100%" }}
  animate={{ x: "calc(100vw - 50%)" }}
/>
It's also possible to animate width and height in to/out of "auto".

<motion.div
  initial={{ height: 0 }}
  animate={{ height: "auto" }}
/>
Note: If additionally animating display in to/out of "none", replace this with visibility "hidden" as elements with display: none can't be measured.

Transform origin
transform-origin has three shortcut values that can be set and animated individually:

originX

originY

originZ

If set as numbers, originX and Y default to a progress value between 0 and 1. originZ defaults to pixels.

<motion.div style={{ originX: 0.5 }} />
CSS variables
Motion for React can animate CSS variables, and also use CSS variable definitions as animation targets.

Animating CSS variables
Sometimes it's convenient to be able to animate a CSS variable to animate many children:

<motion.ul
  initial={{ '--rotate': '0deg' }}
  animate={{ '--rotate': '360deg' }}
  transition={{ duration: 2, repeat: Infinity }}
>
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
</motion.ul>
Note: Animating the value of a CSS variable always triggers paint, therefore it can be more performant to use MotionValues to setup this kind of animation.

CSS variables as animation targets
HTML motion components accept animation targets with CSS variables:

<motion.li animate={{ backgroundColor: "var(--action-bg)" }} />
Transitions
By default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.

For instance, physical properties like x or scale are animated with spring physics, whereas values like opacity or color are animated with duration-based easing curves.

However, you can define your own animations via the transition prop.

<motion.div
  animate={{ x: 100 }}
  transition={{ ease: "easeOut", duration: 2 }}
/>
A default transition can be set for many components with the MotionConfig component:

<MotionConfig transition={{ duration: 0.3 }}>
  <motion.div animate={{ opacity: 1 }} />
  // etc
Or you can set a specific transition on any animation prop:

<motion.div
  animate={{ opacity: 1 }}
  whileHover={{
    opacity: 0.7,
    // Specific transitions override default transitions
    transition: { duration: 0.3 }
  }}
  transition={{ duration: 0.5 }}
/>
Enter animations
When a motion component is first created, it'll automatically animate to the values in animate if they're different from those initially rendered, which you can either do via CSS or via the initial prop. 

<motion.li
  initial={{ opacity: 0, scale: 0 }}
  animate={{ opacity: 1, scale: 1 }}
/>

You can also disable the enter animation entirely by setting initial={false}. This will make the element render with the values defined in animate.

<motion.div initial={false} animate={{ y: 100 }} />
Exit animations
Motion for React can animate elements as they're removed from the DOM.

In React, when a component is removed, it's usually removed instantly. Motion provides the AnimatePresence component which keeps elements in the DOM while they perform an animation defined with the exit prop.

<AnimatePresence>
  {isVisible && (
    <motion.div
      key="modal"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    />
  )}
</AnimatePresence>

Keyframes
So far, we've set animation props like animate and exit to single values, like opacity: 0.

This is great when we want to animate from the current value to a new value. But sometimes we want to animate through a series of values. In animation terms, these are called keyframes.

All animation props can accept keyframe arrays:

<motion.div animate={{ x: [0, 100, 0] }} />

When we animate to an array of values, the element will animate through each of these values in sequence.

In the previous example, we explicitly set the initial value as 0. But we can also say "use the current value" by setting the first value to null.

<motion.div animate={{ x: [null, 100, 0] }} />

This way, if a keyframe animation is interrupting another animation, the transition will feel more natural.

Wildcard keyframes
This null keyframe is called a wildcard keyframe. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).

Wildcard keyframes can be useful for holding a value mid-animation without having to repeat values.

<motion.div
  animate={{ x: [0, 100, null, 0 ] }}
  // same as x: [0, 100, 100, 0] but easier to maintain
/>
Keyframe timing
By default, each keyframe is spaced evenly throughout the animation. You can override this by setting the times option via transition.

times is an array of progress values between 0 and 1, defining where in the animation each keyframe should be positioned.

<motion.circle
  cx={500}
  animate={{
    cx: [null, 100, 200],
    transition: { duration: 3, times: [0, 0.2, 1] }
  }}
/>
0 is the start of the animation, and 1 is the end of the animation. Therefore, 0.2 places this keyframe somewhere towards the start of the animation.

Gesture animations
Motion for React has animation props that can define how an element animates when it recognises a gesture.

Supported gestures are:

whileHover

whileTap

whileFocus

whileDrag

whileInView

When a gesture starts, it animates to the values defined in while-, and then when the gesture ends it animates back to the values in initial or animate.

<motion.button
  initial={{ opacity: 0 }}
  whileHover={{ backgroundColor: "rgba(220, 220, 220, 1)" }}
  whileTap={{ backgroundColor: "rgba(255, 255, 255, 1)" }}
  whileInView={{ opacity: 1 }}
/>

The custom Cursor component available in Motion+ takes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):

<Cursor magnetic />

Variants
Setting animate as a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.

Variants are a set of named targets. These names can be anything.

const variants = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}
Variants are passed to motion components via the variants prop:

<motion.div variants={variants} />
These variants can now be referred to by a label, wherever you can define an animation target:

<motion.div
  variants={variants}
  initial="hidden"
  whileInView="visible"
  exit="hidden"
/>
You can also define multiple variants via an array:

animate={["visible", "danger"]}
I love using variants alongside React state – just pass your state to animate, and now you've got a tidy place to define all your animation targets!

const [status, setStatus] = useState<"inactive" | "active" | "complete">(
  "inactive"
);

<motion.div
  animate={status} // pass in our React state!
  variants={{
    inactive: { scale: 0.9 color: "var(--gray-500)" },
    active: { scale: 1 color: "var(--blue-500)" },
    complete: { scale: 1 color: "var(--blue-500)" }
  }}
>
  <motion.svg
    path={checkmarkPath}
    variants={{
      inactive: { pathLength: 0 },
      active: { pathLength: 0 },
      complete: { pathLength: 1}
    }}
  />
</motion.div>
~ Sam Selikoff


Propagation
Variants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.

Variants will flow down through motion components. So in this example when the ul enters the viewport, all of its children with a "visible" variant will also animate in:

const list = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

const item = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
}

return (
  <motion.ul
    initial="hidden"
    whileInView="visible"
    variants={list}
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)

Orchestration
By default, this children animations will start simultaneously with the parent. But with variants we gain access to new transition props when and delayChildren.

const list = {
  visible: {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      delayChildren: stagger(0.3), // Stagger children by .3 seconds
    },
  },
  hidden: {
    opacity: 0,
    transition: {
      when: "afterChildren",
    },
  },
}
Dynamic variants
Each variant can be defined as a function that resolves when a variant is made active.

const variants = {
  hidden: { opacity: 0 },
  visible: (index) => ({
    opacity: 1,
    transition: { delay: index * 0.3 }
  })
}
These functions are provided a single argument, which is passed via the custom prop:

items.map((item, index) => <motion.div custom={index} variants={variants} />)
This way, variants can be resolved differently for each animating element.

Animation controls
Declarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.

The useAnimate hook can be used for:

Animating any HTML/SVG element (not just motion components).

Complex animation sequences.

Controlling animations with time, speed, play(), pause() and other playback controls.

function MyComponent() {
  const [scope, animate] = useAnimate()

  useEffect(() => {
    const controls = animate([
      [scope.current, { x: "100%" }],
      ["li", { opacity: 1 }]
    ])

    controls.speed = 0.8

    return () => controls.stop()
  }, [])

  return (
    <ul ref={scope}>
      <li />
      <li />
      <li />
    </ul>
  )
}
Animate content
By passing a MotionValue as the child of a motion component, it will render its latest value in the HTML.

import { useMotionValue, motion, animate } from "motion/react"

function Counter() {
  const count = useMotionValue(0)

  useEffect(() => {
    const controls = animate(count, 100, { duration: 5 })
    return () => controls.stop()
  }, [])

  return <motion.pre>{count}</motion.pre>
}
This is more performant than setting React state as the motion component will set innerHTML directly.


It's also possible to animate numbers with a ticking counter effect using the AnimateNumber component in Motion+ by passing them directly to the component:

<AnimateNumber>{value}</AnimateNumber>

Next
In this guide we've covered the basic kinds of animations we can perform in Motion using its animation props. However, there's much more to discover.

Most of the examples on this page have used HTML elements, but Motion also has unique SVG animation features, like its simple line drawing API.

We've also only covered time-based animations, but Motion also provides powerful scroll animation features like useScroll and whileInView.

It also provides a powerful layout animation engine, that can animate between any two layouts using performant transforms.

Finally, there's also a whole Fundamentals examples category that covers all the basics of animating with Motion for React with live demos and copy-paste code.

Motion component
Most React animations in Motion are powered by the <motion /> component.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage
Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"
Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />
But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>
Checkout the Animation guide for a full overview on animations in Motion for React.

Performance
motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering
motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />
This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components
Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)
Your component must pass a ref to the component you want to animate.

React 18: Use forwardRef to wrap the component and pass ref to the element you want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})
React 19: React 19 can pass ref via props:

const Component = (props) => {
  return <div ref={props.ref} />
})
Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')
By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props
motion components accept the following props.

Animation
initial
The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />
Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />
Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate
A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>
Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit
A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition
The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants
The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style
The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate
Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart
Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete
Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover
Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart
Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd
Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap
Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart
Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap
Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel
Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus
Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan
Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />
Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.

delta: Distance since the last event.

offset: Distance from the original event.

velocity: Current velocity of the pointer.

onPanStart
Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd
Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag
Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag
Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints
Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>
Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin
Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic
Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum
Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition
Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock
Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation
Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls
Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)
Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener
Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag
Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />
Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.

delta: Distance since the last event.

offset: Distance from the original event.

velocity: Current velocity of the pointer.

onDragStart
Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd
Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock
Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView
Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport
Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>
Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.

root: The ref of an ancestor scrollable element to detect intersections with (instead of window).

margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".

amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter
Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave
Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout
Default: false

If true, this component will perform layout animations.

<motion.div layout />
If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId
If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}
If the previous component remains in the tree, the two elements will crossfade.

layoutDependency
By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll
For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot
For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart
A callback to run when a layout animation starts.

onLayoutAnimationComplete
A callback to run when a layout animation completes.

Advanced
inherit
Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom
Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate
By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>